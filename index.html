<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Minisign by Frank Denis</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Minisign</h1>
      <h2 class="project-tagline">A dead simple tool to sign files and verify signatures.</h2>
      <a href="https://github.com/jedisct1/minisign" class="btn">View on GitHub</a>
      <a href="https://github.com/jedisct1/minisign/tarball/master" class="btn">Download source code</a>
      <a href="https://github.com/jedisct1/minisign/releases/download/0.8/minisign-osx.zip" class="btn">Download OSX binary</a>
      <a href="https://github.com/jedisct1/minisign/releases/download/0.8/minisign-win32.zip" class="btn">Download Windows binary</a>
    </section>

    <section class="main-content">
      <h1>
<a id="minisign" class="anchor" href="#minisign" aria-hidden="true"><span class="octicon octicon-link"></span></a>Minisign</h1>

<p>Minisign is a dead simple tool to sign files and verify signatures.</p>

<p>It is portable, lightweight, and uses the highly secure
<a href="https://ed25519.cr.yp.to/" target="blank">Ed25519</a> public-key signature system.</p>

<h2>
<a id="creating-a-key-pair" class="anchor" href="#creating-a-key-pair" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating a key pair</h2>

<pre><code>$ minisign -G
</code></pre>

<p>The public key is printed and put into the <code>minisign.pub</code> file. The secret key
is encrypted and saved as a file named <code>~/.minisign/minisign.key</code>.</p>

<h2>
<a id="signing-a-file" class="anchor" href="#signing-a-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Signing a file</h2>

<pre><code>$ minisign -Sm myfile.txt
</code></pre>

<p>Or to include a comment in the signature, that will be verified and
displayed when verifying the file:</p>

<pre><code>$ minisign -Sm myfile.txt -t 'This comment will be signed as well'
</code></pre>

<p>The signature is put into <code>myfile.txt.minisig</code>.</p>

<p>Starting with version 0.8, multiple files can also be signed at once:</p>

<pre><code>$ minisign -Sm file1.txt file2.txt *.jpg
</code></pre>

<h2>
<a id="verifying-a-file" class="anchor" href="#verifying-a-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Verifying a file</h2>

<pre><code>$ minisign -Vm myfile.txt -P RWQf6LRCGA9i53mlYecO4IzT51TGPpvWucNSCh1CBM0QTaLn73Y7GFO3
</code></pre>

<p>or</p>

<pre><code>$ minisign -Vm myfile.txt -p signature.pub
</code></pre>

<p>This requires the signature <code>myfile.txt.minisig</code> to be present in the same
directory.</p>

<p>The public key can either reside in a file (<code>./minisign.pub</code> by default) or be
directly specified on the command line.</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<pre><code>$ minisign -G [-p pubkey] [-s seckey]
$ minisign -S [-H] [-x sigfile] [-s seckey] [-c untrusted_comment] [-t trusted_comment] -m file
$ minisign -V [-x sigfile] [-p pubkeyfile | -P pubkey] [-o] [-q] -m file

-G                generate a new key pair
-S                sign a file
-V                verify that a signature is valid for a given file
-m &lt;file&gt;         file to sign/verify
-o                combined with -V, output the file content after verification
-H                combined with -S, pre-hash in order to sign large files
-p &lt;pubkeyfile&gt;   public key file (default: ./minisign.pub)
-P &lt;pubkey&gt;       public key, as a base64 string
-s &lt;seckey&gt;       secret key file (default: ~/.minisign/minisign.key)
-x &lt;sigfile&gt;      signature file (default: &lt;file&gt;.minisig)
-c &lt;comment&gt;      add a one-line untrusted comment
-t &lt;comment&gt;      add a one-line trusted comment
-q                quiet mode, suppress output
-Q                pretty quiet mode, only print the trusted comment
-f                force. Combined with -G, overwrite a previous key pair
-v                display version number
</code></pre>

<h2>
<a id="trusted-comments" class="anchor" href="#trusted-comments" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trusted comments</h2>

<p>Signature files include an untrusted comment line that can be freely
modified, even after signature creation.</p>

<p>They also include a second comment line, that cannot be modified
without the secret key.</p>

<p>Trusted comments can be used to add instructions or application-specific
metadata (intended file name, timestamps, resource identifiers,
version numbers to prevent downgrade attacks).</p>

<h2>
<a id="compilation--installation" class="anchor" href="#compilation--installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compilation / installation</h2>

<p>Dependencies:</p>

<ul>
<li><a href="http://doc.libsodium.org/">libsodium</a></li>
<li>cmake</li>
</ul>

<p>Compilation:</p>

<pre><code>$ mkdir build
$ cd build
$ cmake ..
$ make
# make install
</code></pre>

<h2>
<a id="compatibility-with-openbsd-signify" class="anchor" href="#compatibility-with-openbsd-signify" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compatibility with OpenBSD signify</h2>

<p>Signature written by minisign can be verified using OpenBSD's signify
tool: public key files and signature files are compatible.</p>

<p>However, minisign uses a slightly different format to store secret keys.</p>

<p>Minisign signatures include trusted comments in addition to untrusted
comments. Trusted comments are signed, thus verified, before being
displayed.</p>

<p>This adds two lines to the signature files, that signify silently ignores.</p>

<h2>
<a id="signature-format" class="anchor" href="#signature-format" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pre-hashing</h2>

<p>By default, signing and verification require as much memory as the size of the file.</p>

<p>Since Minisign 0.6, huge files can be signed and verified with very low memory requirements, by pre-hashing the content.</p>

<p>The <code>-H</code> command-line switch, in combination with <code>-S</code>, generates a pre-hashed signature (HashEdDSA):</p>

<pre><code>$ minisign -SHm myfile.txt</code></pre>

<p>Verification of such a signature doesn't require any specific switch: the appropriate algorithm will automatically be detected.</p>

<p>Signatures generated that way are not compatible with OpenBSD's signify tool and are not compatible with Minisign versions prior to 0.6.</p>

<h2>
<a id="signature-format" class="anchor" href="#signature-format" aria-hidden="true"><span class="octicon octicon-link"></span></a>Signature format</h2>

<pre><code>untrusted comment: &lt;arbitrary text&gt;
base64(&lt;signature_algorithm&gt; || &lt;key_id&gt; || &lt;signature&gt;)
trusted_comment: &lt;arbitrary text&gt;
base64(&lt;global_signature&gt;)
</code></pre>

<ul>
<li>
<code>signature_algorithm</code>: <code>Ed</code> (for PureEdDSA) or <code>ED</code> (for HashedEdDSA)
</li>
<li>
<code>key_id</code>: 8 random bytes, matching the public key</li>
<li>
<code>signature</code> (PureEdDSA): <code>ed25519(&lt;file data&gt;)</code>
</li>
<li>
<code>signature</code> (HashedEdDSA): <code>ed25519(Blake2b-512(&lt;file data&gt;))</code>
</li>
<li>
<code>global_signature</code>: <code>ed25519(&lt;signature&gt; || &lt;trusted_comment&gt;)</code>
</li>
</ul>

<h2>
<a id="public-key-format" class="anchor" href="#public-key-format" aria-hidden="true"><span class="octicon octicon-link"></span></a>Public key format</h2>

<pre><code>untrusted comment: &lt;arbitrary text&gt;
base64(&lt;signature_algorithm&gt; || &lt;key_id&gt; || &lt;public_key&gt;)
</code></pre>

<ul>
<li>
<code>signature_algorithm</code>: <code>Ed</code>
</li>
<li>
<code>key_id</code>: 8 random bytes</li>
<li>
<code>public_key</code>: Ed25519 public key</li>
</ul>

<h2>
<a id="secret-key-format" class="anchor" href="#secret-key-format" aria-hidden="true"><span class="octicon octicon-link"></span></a>Secret key format</h2>

<pre><code>untrusted comment: &lt;arbitrary text&gt;
base64(&lt;signature_algorithm&gt; || &lt;kdf_algorithm&gt; || &lt;cksum_algorithm&gt; ||
       &lt;kdf_salt&gt; || &lt;kdf_opslimit&gt; || &lt;kdf_memlimit&gt; || &lt;keynum_sk&gt;)
</code></pre>

<ul>
<li>
<code>signature_algorithm</code>: <code>Ed</code>
</li>
<li>
<code>kdf_algorithm</code>: <code>Sc</code>
</li>
<li>
<code>cksum_algorithm</code>: <code>B2</code>
</li>
<li>
<code>kdf_salt</code>: 32 random bytes</li>
<li>
<code>kdf_opslimit</code>: <code>crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE</code>
</li>
<li>
<code>kdf_memlimit</code>: <code>crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE</code>
</li>
<li>
<code>keynum_sk</code>: <code>&lt;kdf_output&gt; ^ (&lt;key_id&gt; || &lt;secret_key&gt; || &lt;public_key&gt; || &lt;checksum&gt;)</code>, 104 bytes
</li>
<li>
<code>key_id</code>: 8 random bytes</li>
<li>
<code>secret_key</code>: Ed25519 secret key</li>
<li>
<code>public_key</code>: Ed25519 public key</li>
<li>
<code>checksum</code>: <code>Blake2b-256(&lt;signature_algorithm&gt; || &lt;key_id&gt; || &lt;secret_key&gt; || &lt;public_key&gt;)</code>, 32 bytes</li>
</ul>

<h2>
<a id="encryption" class="anchor" href="#encryption" aria-hidden="true"><span class="octicon octicon-link"></span></a>Encryption</h2>

Looking for an equally simple tool for file and stream encryption? Check out <a href="https://github.com/jedisct1/encpipe">Encpipe</a>.

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jedisct1/minisign">Minisign</a> is maintained by <a href="https://github.com/jedisct1">jedisct1</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>


  </body>
</html>
